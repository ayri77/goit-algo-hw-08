# Домашнє завдання 08 - Робота з купами (Heaps)

## Опис проекту

Цей міні-проект містить реалізацію алгоритмів, що використовують структуру даних "купа" (heap) для вирішення практичних задач оптимізації та об'єднання даних.

## Завдання 1: Об'єднання мережевих кабелів з мінімальними витратами

### Постановка задачі

Є декілька мережевих кабелів різної довжини. Потрібно об'єднати їх по два за раз в один кабель, використовуючи з'єднувачі, у порядку, який призведе до найменших витрат. 

**Умови:**
- Витрати на з'єднання двох кабелів дорівнюють їхній сумі довжин
- Загальні витрати дорівнюють сумі з'єднання всіх кабелів
- Потрібно знайти порядок об'єднання, який мінімізує загальні витрати

### Алгоритм

Використовується **мінімальна купа (Min Heap)** для завжди вибору двох найкоротших кабелів:

1. Створюється мінімальна купа з усіх кабелів
2. Поки в купі більше одного кабеля:
   - Витягується два найкоротші кабелі (мінімуми)
   - Вони об'єднуються в один кабель
   - Новий кабель додається назад до купи
   - Витрати на з'єднання додаються до загальних витрат
3. Повертається мінімальна загальна вартість

### Реалізація

- **Клас `MinHeap`**: реалізація мінімальної купи з методами:
  - `insert()` - додавання елемента
  - `extract_min()` - витягування мінімального елемента
  - `build_heap()` - побудова купи з масиву
  - `heapify_up()` / `heapify_down()` - підтримка властивостей купи

### Приклад використання

```python
cables = [1.5, 2.1, 3.3, 4.9, 5.5, 2.4, 3.2]
# Мінімальна вартість об'єднання буде розрахована автоматично
```

**Складність:** O(n log n), де n - кількість кабелів

---

## Завдання 2: Об'єднання k відсортованих списків

### Постановка задачі

Дано k відсортованих списків цілих чисел. Потрібно об'єднати їх у один відсортований список, використовуючи мінімальну купу для ефективного злиття.

**Приклад:**
```python
lists = [[1, 4, 5], [1, 3, 4], [2, 6]]
merged_list = merge_k_lists(lists)
# Результат: [1, 1, 2, 3, 4, 4, 5, 6]
```

### Реалізовані варіанти

Було реалізовано та протестовано **три різні підходи** до вирішення задачі:

#### 1. `merge_k_lists_list` - Використання списків з індексами
- Зберігає в купі кортежі `(значення, індекс_списку, індекс_елемента)`
- При витягуванні мінімуму збільшує індекс елемента в відповідному списку
- Переваги: не потребує додаткових структур даних
- Недоліки: доступ за індексом O(1), але потребує зберігання додаткових індексів

#### 2. `merge_k_lists_deque` - Використання черг (deque)
- Конвертує списки в `collections.deque`
- Зберігає в купі кортежі `(значення, індекс_списку)`
- Використовує `popleft()` для отримання наступного елемента
- Переваги: ефективне видалення з початку O(1)
- Недоліки: потребує конвертації списків у deque

#### 3. `merge_k_lists_inverted_list` - Використання інвертованих списків
- Інвертує списки (крім першого елемента) для використання `pop()`
- Зберігає в купі кортежі `(значення, індекс_списку)`
- Використовує `pop()` для отримання наступного елемента
- Переваги: не потребує додаткових бібліотек, `pop()` з кінця O(1)
- Недоліки: потребує інвертування списків

### Результати тестування продуктивності

Тестування проводилося на різних розмірах даних з усередненням по 3 запусках:

#### Тест 1: k=5 списків, довжина 10-50 елементів
```
list+index                     | ok=True | avg_time=0.000111 s
deque+popleft                  | ok=True | avg_time=0.000171 s
reversed+pop                   | ok=True | avg_time=0.000099 s
```

#### Тест 2: k=10 списків, довжина 50-200 елементів
```
list+index                     | ok=True | avg_time=0.001004 s
deque+popleft                  | ok=True | avg_time=0.000920 s
reversed+pop                   | ok=True | avg_time=0.000905 s
```

#### Тест 3: k=50 списків, довжина 100-300 елементів
```
list+index                     | ok=True | avg_time=0.012868 s
deque+popleft                  | ok=True | avg_time=0.013126 s
reversed+pop                   | ok=True | avg_time=0.012957 s
```

#### Тест 4: k=100 списків, довжина 100-500 елементів
```
list+index                     | ok=True | avg_time=0.040795 s
deque+popleft                  | ok=True | avg_time=0.038896 s
reversed+pop                   | ok=True | avg_time=0.038688 s
```

### Висновки з тестування

1. **Коректність**: Всі три реалізації працюють коректно і дають однакові результати (ok=True для всіх тестів)

2. **Продуктивність на малих даних** (k=5, довжина 10-50):
   - Найшвидший: `reversed+pop` (0.000099 с)
   - Найповільніший: `deque+popleft` (0.000171 с)
   - Різниця незначна через малий обсяг даних

3. **Продуктивність на середніх даних** (k=10, довжина 50-200):
   - Найшвидший: `reversed+pop` (0.000905 с)
   - `deque+popleft` та `reversed+pop` показують майже однакову продуктивність
   - `list+index` трохи повільніший

4. **Продуктивність на великих даних** (k=50-100):
   - Всі три методи показують дуже близьку продуктивність
   - `reversed+pop` має невелику перевагу на найбільших тестах
   - Різниця між методами мінімальна (<5%)

5. **Рекомендації**:
   - **Для практичного використання**: `reversed+pop` - найпростіший у реалізації, не потребує додаткових бібліотек, показує найкращу продуктивність
   - **Для навчальних цілей**: `list+index` - найбільш зрозумілий підхід, демонструє роботу з індексами
   - **Для специфічних випадків**: `deque+popleft` може бути корисним, якщо вже використовуються черги в проекті

**Складність:** O(n log k), де n - загальна кількість елементів, k - кількість списків

---

## Структура проекту

```
goit-algo-hw-08/
├── src/
│   ├── task1.py      # Завдання 1: Об'єднання кабелів
│   └── task2.py      # Завдання 2: Об'єднання k списків
├── tests/            # Тести (якщо є)
├── main.py           # Головний файл
├── pyproject.toml    # Конфігурація проекту
└── README.md         # Документація
```

## Запуск

### Завдання 1
```bash
python src/task1.py
```

### Завдання 2
```bash
python src/task2.py
```

## Технології

- Python 3.x
- Стандартна бібліотека Python (collections.deque для одного з варіантів)

## Автор

Виконано в рамках курсу алгоритмів та структур даних.
